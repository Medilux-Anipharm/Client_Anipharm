/**
 * Pickup Service
 * 픽업 요청 관련 API 서비스
 */

import apiClient from './api';
import {
  PickupRequest,
  PickupStats,
  CreatePickupRequestData,
  UpdatePickupStatusData,
} from '../types/pickup';

class PickupService {
  // ==========================================
  // 고객용 API
  // ==========================================

  /**
   * 픽업 요청 생성
   * @param data - 픽업 요청 데이터
   * @returns 생성된 픽업 요청
   */
  async createPickupRequest(data: CreatePickupRequestData): Promise<PickupRequest> {
    try {
      const response = await apiClient.post<{
        success: boolean;
        data: PickupRequest;
        message: string;
      }>('/pickup/request', data);

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 요청 생성에 실패했습니다.'
      );
    }
  }

  /**
   * 내 픽업 요청 목록 조회
   * @param status - 상태 필터 (선택사항)
   * @returns 픽업 요청 목록
   */
  async getMyPickupRequests(status?: string): Promise<PickupRequest[]> {
    try {
      const response = await apiClient.get<{
        success: boolean;
        data: PickupRequest[];
        count: number;
      }>('/pickup/my-requests', {
        params: status ? { status } : {},
      });

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 요청 목록 조회에 실패했습니다.'
      );
    }
  }

  /**
   * 픽업 요청 상세 조회
   * @param pickupId - 픽업 요청 ID
   * @returns 픽업 요청 상세
   */
  async getPickupRequestDetail(pickupId: number): Promise<PickupRequest> {
    try {
      const response = await apiClient.get<{
        success: boolean;
        data: PickupRequest;
      }>(`/pickup/${pickupId}`);

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 요청 조회에 실패했습니다.'
      );
    }
  }

  /**
   * 픽업 취소 (고객)
   * @param pickupId - 픽업 요청 ID
   * @param cancelReason - 취소 사유
   * @returns 취소된 픽업 요청
   */
  async cancelPickupRequest(
    pickupId: number,
    cancelReason?: string
  ): Promise<PickupRequest> {
    try {
      const response = await apiClient.put<{
        success: boolean;
        data: PickupRequest;
        message: string;
      }>(`/pickup/${pickupId}/cancel`, {
        cancelReason,
      });

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 취소에 실패했습니다.'
      );
    }
  }

  // ==========================================
  // 약국용 API
  // ==========================================

  /**
   * 약국의 픽업 요청 목록 조회
   * @param status - 상태 필터 (선택사항)
   * @returns 픽업 요청 목록
   */
  async getPharmacyPickupRequests(status?: string): Promise<{
    data: PickupRequest[];
    count: number;
  }> {
    try {
      const response = await apiClient.get<{
        success: boolean;
        data: PickupRequest[];
        count: number;
      }>('/pickup/pharmacy/requests', {
        params: status ? { status } : {},
      });

      return {
        data: response.data.data,
        count: response.data.count,
      };
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 요청 목록 조회에 실패했습니다.'
      );
    }
  }

  /**
   * 약국 통계 조회
   * @returns 픽업 통계
   */
  async getPharmacyStats(): Promise<PickupStats> {
    try {
      const response = await apiClient.get<{
        success: boolean;
        data: PickupStats;
      }>('/pickup/pharmacy/stats');

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '통계 조회에 실패했습니다.'
      );
    }
  }

  /**
   * 픽업 상태 업데이트 (약국)
   * @param pickupId - 픽업 요청 ID
   * @param data - 업데이트 데이터
   * @returns 업데이트된 픽업 요청
   */
  async updatePickupStatus(
    pickupId: number,
    data: UpdatePickupStatusData
  ): Promise<PickupRequest> {
    try {
      const response = await apiClient.put<{
        success: boolean;
        data: PickupRequest;
        message: string;
      }>(`/pickup/pharmacy/${pickupId}/status`, data);

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '상태 업데이트에 실패했습니다.'
      );
    }
  }

  /**
   * 픽업 완료 처리 (약국)
   * @param pickupId - 픽업 요청 ID
   * @returns 완료된 픽업 요청
   */
  async completePickup(pickupId: number): Promise<PickupRequest> {
    try {
      const response = await apiClient.put<{
        success: boolean;
        data: PickupRequest;
        message: string;
      }>(`/pickup/pharmacy/${pickupId}/complete`);

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 완료 처리에 실패했습니다.'
      );
    }
  }

  /**
   * 픽업 취소 (약국)
   * @param pickupId - 픽업 요청 ID
   * @param cancelReason - 취소 사유
   * @returns 취소된 픽업 요청
   */
  async cancelPickupByPharmacy(
    pickupId: number,
    cancelReason: string
  ): Promise<PickupRequest> {
    try {
      const response = await apiClient.put<{
        success: boolean;
        data: PickupRequest;
        message: string;
      }>(`/pickup/pharmacy/${pickupId}/cancel`, {
        cancelReason,
      });

      return response.data.data;
    } catch (error: any) {
      throw new Error(
        error.response?.data?.message || '픽업 취소에 실패했습니다.'
      );
    }
  }

  // ==========================================
  // 유틸리티 함수
  // ==========================================

  /**
   * 픽업 상태를 한글로 변환
   * @param status - 픽업 상태
   * @returns 한글 상태명
   */
  getStatusText(status: string): string {
    const statusMap: Record<string, string> = {
      REQUESTED: '요청됨',
      REJECTED: '거절됨',
      WAITING: '재고 대기',
      ACCEPTED: '수락됨',
      PREPARING: '준비 중',
      READY: '픽업 대기',
      COMPLETED: '픽업 완료',
      CANCELED: '취소됨',
    };
    return statusMap[status] || status;
  }

  /**
   * 픽업 상태 색상 가져오기
   * @param status - 픽업 상태
   * @returns 색상 코드
   */
  getStatusColor(status: string): string {
    const colorMap: Record<string, string> = {
      REQUESTED: '#2196F3',   // 파랑
      REJECTED: '#F44336',    // 빨강
      WAITING: '#FF9800',     // 주황
      ACCEPTED: '#4CAF50',    // 초록
      PREPARING: '#9C27B0',   // 보라
      READY: '#00BCD4',       // 청록
      COMPLETED: '#4CAF50',   // 초록
      CANCELED: '#9E9E9E',    // 회색
    };
    return colorMap[status] || '#666666';
  }

  /**
   * 픽업 상태에 따른 아이콘 이름 가져오기
   * @param status - 픽업 상태
   * @returns Ionicons 아이콘 이름
   */
  getStatusIcon(status: string): string {
    const iconMap: Record<string, string> = {
      REQUESTED: 'time-outline',
      REJECTED: 'close-circle-outline',
      WAITING: 'hourglass-outline',
      ACCEPTED: 'checkmark-circle-outline',
      PREPARING: 'build-outline',
      READY: 'checkmark-done-outline',
      COMPLETED: 'checkmark-done-circle',
      CANCELED: 'ban-outline',
    };
    return iconMap[status] || 'help-circle-outline';
  }

  /**
   * 날짜 포맷팅
   * @param dateString - ISO 날짜 문자열
   * @returns 포맷된 날짜 (예: 2026.01.09 14:30)
   */
  formatDate(dateString?: string): string {
    if (!dateString) return '-';

    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');

    return `${year}.${month}.${day} ${hours}:${minutes}`;
  }

  /**
   * 상대적 시간 표시
   * @param dateString - ISO 날짜 문자열
   * @returns 상대적 시간 (예: 10분 전, 2시간 전)
   */
  getRelativeTime(dateString?: string): string {
    if (!dateString) return '-';

    const now = new Date();
    const date = new Date(dateString);
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffMins < 1) return '방금 전';
    if (diffMins < 60) return `${diffMins}분 전`;
    if (diffHours < 24) return `${diffHours}시간 전`;
    if (diffDays < 7) return `${diffDays}일 전`;

    return this.formatDate(dateString);
  }

  /**
   * 픽업 가능 여부 확인
   * @param status - 픽업 상태
   * @returns 픽업 가능 여부
   */
  canPickup(status: string): boolean {
    return status === 'READY';
  }

  /**
   * 취소 가능 여부 확인
   * @param status - 픽업 상태
   * @returns 취소 가능 여부
   */
  canCancel(status: string): boolean {
    return ['REQUESTED', 'ACCEPTED', 'WAITING'].includes(status);
  }
}

export default new PickupService();
